# 리팩터링 원칙

- - -

### 리팩터링?
* 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
* 동작을 보존하는 작은 단계를 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어낸다.
* 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.
  * 성능이 좋아질 수도, 나빠질 수도 있다.
  * 성능 최적화는 오로지 속도 개선에만 신경쓴다. 목표 성능에 반드시 도달해야 한다면 코드는 다루기 더 어렵게 바뀔 수 있다.
* 처음부터 좋은 설계를 마련하기는 매우 어렵기 때문에 리팩터링은 반드시 필요하다.

### 리팩터링 시 고려할 문제

#### 새 기능 개발 속도 저하
* 리팩터링 때문에 새 기능을 개발하는 속도가 느려진다고 여기지만, 리팩터링의 궁극적인 목적은 개발 속도를 높이는 데 있다.
* 리팩터링을 '클린 코드'와 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 하는 것을 지양해야 한다.
  * 리팩터링은 기능 추가 시간을 줄이고, 버그 수정 시간을 줄임으로써 경제적 효과를 누리기 위함이다.

#### 코드 소유권
* 코드 소유권이 나뉘어 있으면 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문에 리팩터링에 방해가 된다.
* 코드 소유권을 느슨하게 정하여 변경 사항 커밋을 클라이언트를 관리하는 쪽해서 승인하는 방식은 대규모 시스템 개발 시 잘 어울린다.

#### 브랜치
* 독립 브랜치로 작업하는 기간이 길어질 수록 작업 결과를 마스터로 통합하기 어려워진다.
* 브랜치들을 마스터로 통합하는 주기를 짧게 가져가서 머지할 때의 복잡도를 최소한으로 하는 것이 좋다. (CI, Continuous Integration)
  * 리팩터링을 하다보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 있는데, 머지 과정에서 의미 충돌이 생기기 쉽기 때문이다.

#### 테스팅
* 리팩터링은 프로그램의 겉보기 동작은 똑같이 유지되어야 한다.
* 하지만 실수를 하는 경우가 있을 수 있는데, 이때 적절한 테스트 스위트(test suite)가 필요하다.
* 따라서 리팩터링을 위해서는 자가 테스트 코드가 필요하다.
  * 자가 테스트 코드는 리팰터링을 할 수 있게 해줄 뿐만 아니라, 새 기능을 추가도 안전하게 진행할 수 있도록 도와준다.
  * 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴 볼 수 있다.
  * 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다.
* 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 매커니즘으로 활용할 수 있어서 CI와도 밀접하게 연관된다.

#### 레거시 코드
* 레거시 시스템을 파악할 대 리팩터링은 굉장히 도움이 된다.
* 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩토링하기는 어렵다. 이러한 문제는 테스트 보강을 통해 해결한다.
  * 프로그름에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다.
* 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다.
  * 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 크다는 뜻이기 때문이다.

- - -

### 리팩터링, 아키텍처, 애그니(YAGNI)
* 우리는 소프트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다하다.
* 위 문제를 해결하기 위한 한 가지 방법으로, 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어두는 것이다.
  * 함수를 정의하다보면 범용적으로 사용할 수 있겠다는 생각이 들 때가 있다. 이런 경우에 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가한다. 이런 매개변수들이 유연성 메커니즘이다.
  * 하지만 매개변수를 생각나는 대로 추가하다 보면 당장의 쓰임에 비해 함수가 너무 복잡해진다.
  * 깜빡 잊은 매개변수가 있다면 앞서 추가해둔 매개변수들 때무넹 새로 추가하기가 더 어려워 질 수 있다.
* 리팩터링을 활용하면 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축할 수 있다.
  * 진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.
  * 그 과정에서 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하지만, 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다.
  * 호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않는다. 그러다 매개변수를 추가해야 할 시점이 오면 간단한 리팩터링 기법인 **함수 매개변수화하기**로 해결한다.
  * 예상되는 변경을 미리 반영하는 리팩터링을 미루면 나중에 얼마나 어려워질지를 가늠해보면 판단에 도움에 도움될 때가 많다.
  * 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가한다.
* 이런 식으로 설계하는 방식을 간결한 설계(simple design), 점진적 설계(incremental design), YAGNI("you aren't going to need it", "필요 없을 거다"의 줄임말) 등으로 불른다.

- - -

### 리팩터링과 소프트웨어 개발 프로세스
* 리팩터링은 팀이 따르는 실천법에 따라 효과가 크게 달라진다.
* 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD)이라 한다.
* 리팩터링의 첫 번째 토대는 자가 테스트 코드다.
  * 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다.
  * 지속적 통합(CI)를 통해 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유해야 한다.
* 추측에 근거한 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽다.
* 자가 테스트 코드, 지속적 통합, 리팩터링의 세 가지 실천법을 잘 조화시키면 요구사항 변화에 재빠르게 대응하고 안정적인 선순환 구조를 코드베이스에 심을 수 있다.

- - -

### 리팩터링과 성능
* '직관적인 설계' vs '성능'은 중요한 주제다.
  * 리팩터링을 하면 소프퉤어가 느려질 수도 있는 건 사실이다.
  * 하지만 그와 동시에 성능을 튜닝하기 시워진다.

#### 빠른 소프트웨어를 작성하는 세 가지 방법
* 시간 예산 분배 방식
  * 하드 리얼타임 시스템에서 많이 사용한다.
  * 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다.
  * 컴포넌트는 할당된 예산을 초과할 수 없다. 단, 주어진 자원을 서로 주고받는 메커니즘을 제공할 수는 있다.
* 끊임없이 관심을 기울이는 방법
  * 프로그래머라면 누구나 높은 성능을 유지하기 위해 무슨 일이든 한다.
  * 성능을 개선하기 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉽고, 결국 개발이 더뎌질 수 있다.
* 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중하는 방법
  * 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.
  * 그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간 낭비가 될 수 있다.
  * 성능 최적화 단계가 되면 구체적인 절차를 따라 프로그램을 튜닝한다.
    * 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아내어 성능에 큰 영향을 주는 작은 부분들을 찾아 개선한다.
    * 리팩터링할 때처럼 최적화를 위한 수정도 작은 단계로 나눠서 진행한다.
    * 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다.
    * 성능이 개선되지 않았다면 수정 내용을 되돌린다.
    * 사용자가 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 반복한다.
