## 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)

### as-is
```javascript
const basePrice = this._quantity * this._itemPrice;
if (basePrice > 1000)
    return basePrice * 0.95;
else
    return basePRice * 0.98;
```

### to-be
```javascript
get basePrice() {this._quantity * this._itemPrice;}
...
if (this.basePrice > 1000)
    return this.basePrice * 0.95;
else
    return this.basePrice * 0.98;
```

* 함수 안에서 어떤 코드의 결과값을 뒤에서 다시 참조할 목적으로 임시 변수를 쓰기도 하는데, 값을 계산하는 코드가 반복되는 걸 줄이고 변수명을 통해 의미를 설명할 수도 있어서 유용하다.
* 하지만 함수로 만들어 사용하는 편이 더 나을 때가 많다.
* 긴 함수의 한 부분을 별도 함수로 추출하고자 할 때 먼저 변수들을 각각의 함수로 만들면 추출할 함수에 변수를 따로 전달할 필요없기 때문에 일이 수월해진다.
  * 추출한 함수와 원래 함수의 경계가 더 분명해져서 부자연스러운 의존 관계나 부수효과를 찾고 제거하는 데 도움이 된다.
* 클래스 안에서 적용할 때 효과가 가장 크다. 클래스는 추출할 메서드들에 공유 컨텍스트를 제공하기 때문이다.
* 클래스 바깥의 최상위 함수로 추출하면 매개변수가 많아져서 함수를 사용하는 장점이 줄어든다.
* 임시 변수를 질의 함수로 바꾼다고 무조건 좋아지는 것은 아니다.
* 변수는 값을 한 번만 계산하고 그 뒤로는 읽기만 해야한다.
  * 변수에 값을 한 번 대입한 뒤 더 복잡한 코드 덩어리에서 여처 차례 다시 대입하는 경우는 모두 질의 함수로 추출해야 하낟.
  * 계산 로직은 변수가 다음번에 사용될 때 수행해도 똑같은 결과를 내야한다.
* 스냅샷 용도로 사용하는 변수에는 이 리팩터링을 적용해서는 안된다.

- - -

### 절차
1. 변수가 사용되기 전에 값이 확실히 결정되는지, 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지는 않는지 확인한다.
2. 읽기전용으로 만들 수 있는 변수는 읽기전용으로 만든다.
3. 테스트한다.
4. 변수 대입문을 함수로 추출한다.
5. 테스트한다.
6. 변수 인라인하기로 임시 변수를 제거한다.
