## 레코드 캡슐화하기 (Encapsulate Record)

### as-is

```javascript
organization = {name: "hello", country: "GB"};
```

### to-be

```javascript
class Organization {
    constructor(data) {
        this._name = data.name;
        this._country = data.country;
    }

    get name() {
        return this._name;
    }

    set name(arg) {
        this._name = arg;
    }

    get country() {
        return this._country;
    }
    
    set country(arg) {
        this._country = arg;
    }
}
```

* 레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 각각을 따로 취급할 때보다 의미 있는 단위로 전달할 수 있다.
* 하지만 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 하는 단점이 있다.
* 객체를 사용하면 어떻게 저장했는지를 숨긴 채 세 가지 값을 각각의 메서드로 제공할 수 있다.
* 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요가 없다.
* 가변 데이터일 때는 객체를 활용하고, 불변 데이터일 경우엔 레코드(또는 불변 객체)를 사용한다.

- - -

### 절차
1. 레코드를 담은 변수를 캡슐화한다.
2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
3. 테스트한다.
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
5. 레코드를 반환하는 예전 함수를 사용하는 코드를 4에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다.
   * 중첩된 구조처럼 복잡한 레코드라면, 먼저 데이터들을 갱신하는 클라이언트들에 주의해서 살펴보고, 클라이언트가 데이터를 읽기만 한다면 데이터의 복제본이나 읽기전용 프록시를 반환할지 고려해본다.
6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수를 제거한다.
7. 테스트한다.
8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.
