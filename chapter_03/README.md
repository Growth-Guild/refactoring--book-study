# 코드에서 나는 악취

- - -

### 기이한 이름
* 코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 '이름'이다.
* 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 이름을 지어야 한다.
* 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 있다. 그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

### 중복 코드
* 코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.
* 가장 단한단 중복 코드의 예로, 한 클래스에 달린 두 메서드가 똑같은 표현식을 사용하는 경우에 **함수 추출하기**를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다.
* 코드가 비슷하긴 한데 완전히 똑같지는 않다면, **문장 슬라이드하기**로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.
* 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, 각자 따로 호출되지 않도록 메서드 올리기를 적용해 부모로 옮긴다.

### 긴 함수
* 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나온다.
* 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.
  * 그러기 위해서는 함수를 적극적으로 쪼개야 한다.
* 함수 이름은 동작 방식이 아닌 '의도'가 드러나게 지어야 한다.
* 원래 코드보다 길어지더라도 함수를 뽑는다. 단, 함수 이름에 코드의 목적을 드러내야 한다.
* 함수를 짧게 만드는 작업의 대부분은 함수 추출하기가 차지한다.
* 함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다.
  * 이런 상황에서는 함수를 추출하다 보면 함수에도 매개변수가 너무 많아져서 리팩터링 전보다 난해해질 수 있다.
  * '임시 변수를 질의 함수로 바꾸기'로 임시 변수의 수를, '매개변수 객체 만들기'와 '객체 통째로 넘기기'로는 매개 변수의 수를 줄일 수 있다.

### 긴 매개변수 목록
* 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, '매개변수를 질의 함수로 바꾸기'로 제거할 수 있다.
* 사용중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 '객체 통째로 넘기기'를 적용해서 원본 데이터 구조를 그대로 전달한다.
* 항상 함꼐 전달되는 매개변수들은 '매개변수 객체 만들기'로 하나로 묶는다.
* 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 '플래그 인수 제거하기'로 없앤다.

### 전역 데이터
* 전역 데이터는 코드베이스 어디에서든 접근할 수 있고, 값을 누가 바꿨는지 찾아낼 메커니즘이 없다.
* 전역 데이터로 인해 발생하는 문제점을 방지하기 위해 사용하는 리팩터링은 '변수 캡슐화하기'다.
  * 이런 데이터 함수를 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통재할 수 있게 된다.
  * 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.


### 가변 데이터
* 가변 데이터는 변경할 때 발생할 수 있는 사이드 이펙트를 예상하지 못하여 버그로 이어지는 경우가 종종 있다. 
* 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.
* '변수 캡슐화하기'를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
* 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 '변수 쪼개기'를 이용하여 용도별로 독립 변수에 저장하여 값 갱신 문제를 일으킬 여지를 없애야 한다.
* '여러 함수를 클래스로 묶기'나 '여러 함수를 변환 함수로 묶기'를 활용해서 변수를 갱신하는 코드들의 유효 범위를 제한한다.

### 뒤엉킨 변경
* 뒤엉킨 변경은 단일 책임 원칙(SRP, Single Responsibility Principle)이 제대로 지켜지지 않을 때 나타난다.
* 순차적으로 실행되는 게 자연스러운 맥락이면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다.
* 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다.
  * 여러 맥락의 일에 관려하는 함수가 있다면 옮기기 전에 '함수 추출하기'부터 수행한다.
  * 모듈이 클래스라면 '클래스 추출하기'를 수행한다.

### 산탄총 수술
* 산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다.
* 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 냄새를 풍긴다.
* 함께 변경되는 대상들을 '함수 옮기기'와 '필드 옮기기'로 모두 한 모듈에 묶어두면 좋다.
* 비슷한 데이터를 다루는 함수가 많다면 '여러 함수를 클래스로 묶기'를 적용한다.
* 데이터 구조를 변환하거나 보강하는 함수들에는 '여러 함수를 변환 함수로 묶기'를 적용한다.
* 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 '단계 쪼개기'를 적용한다.
* 어설프게 문리된 로직을 '함수 인라인하기'나 '클래스 인라인하기' 같은 인라인 리팩터링으로 하나로 합치는 것도 산탄총 수술에 대처하는 좋은 방법이다.

### 기능 편애
* 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.

### 데이터 뭉치
* 필드 형태의 데이터 뭉치는 '클래스 추출하기'를 수행하여 하나의 객체로 묶는다.
* '매개변수 객체 만들기'나 '객체 통재로 넘기기'를 적용해서 매개변수 수를 줄인다.

### 기본형 집착
* '기본형을 객체 바꾸기'로 적용하여 단순히 문자열, 숫자형 데이터 자료형에 의미를 부여한다.
* 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 '타입 코드를 서브클래스로 바꾸기'와 '조건부 로직을 다형성으로 바꾸기'를 차례로 적용한다.
* 함께 사용되는 기본형 그룹의 데이터 뭉치는 '클래스 추출하기', '매개변수 객체 만들기'를 이용하여 하나의 객체로 묶는다.

### 반복되는 switch문
* 똑같은 조건부 로직으로 반복해서 등장하는 코드를 다형성을 이용하여 제거한다.

### 반복문
* '반복문을 파이프라인으로 바꾸기'를 적용하여 filter나 map 같은 파이프라인 연산을 사용하여 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있게 한다.

### 성의 없는 요소
* 불필요한 구조가 있을 때에는 제거하는게 좋다.
* '함수 인라인하기'나 '클래스 인라인하기'로 처리한다.
* 상속을 사용했다면 '계층 합치기'를 적용한다.

### 추측성 일반화
* 나중에 필요할 거라는 생각으로 당장 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍기는 냄새다.
* 하는 일이 거의 없는 추상 클래스는 '계층 합치기'로 제거한다.
* 쓸데없이 위임하는 코드는 '함수 인라인하기'나 '클래스 인라인하기'로 삭제한다.
* 본문에서 사용하지 않는 매개변수는 '함수선언 바꾸기'로 없앤다.
* 테스트 코드 말고는 사용하는 곳이 없는 코드는 테스트 코드부터 삭제한 뒤에 '죽은 코드 제거하기'로 날려버린다.

### 임시 필드
* 특정 상황에서만 값이 설정되는 필드를 가진 클래스는 '클래스 추출하기'로 이러한 필드들을 추출한다.
  * 객체를 가져올 때는 모든 필드가 채워져 있으리라 기대하기 때문이다.
* 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직은 '특이 케이스 추가하기'로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거한다.

### 메시지 체인
* 메시지 체인은 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. (내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.)
* 이 문제는 '위임 숨기기'로 해결한다. 
  * 이는 체인을 구성하는 모든 객체에 적용할 수 있지만, 중간 객체들이 모두 중개자가 돼버리기 쉽다.
  * 그러므로 '함수 추출하기'로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 '함수 옮기기'로 체인을 숨길 수 있는지 살펴본다.
  * 체인을 구성하는 객체 중 특정 하나를 사용하는 클라이언트 중 그 이후의 객체들도 사용하길 원하는 클라이언트가 제법 된다면, 이 요구를 처리해줄 메서드를 추가한다.

### 중개자
* 객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다.
* 중개자는 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 해당 클래스는 너무 많은 의존성이 생길 것이다.
* 이런 경우는 '중개자 제거하기'로 실제로 일을 하는 객체와 직접 소통하게 한다.
* 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인한다.

### 내부자 거래
* 모듈 사이의 데이터 거래가 많으면 결합도가 높아지므로 그 빈도를 최소로 줄이고 모두 투명하게 처리해야 한다.
* 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 '위임 숨기기'를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.
* 상속 구조에서는 자식 클래스가 부모 클래스에 대해 너무 많은 정보를 의존하게 된다면 '서브 클래스를 위임으로 바꾸기'나 '슈퍼 클래스를 위임으로 바꾸기'를 활용한다.

### 거대한 클래스
* 한 클래스가 너무 많은 일을 하혀다 보면 필드 수가 상당히 늘어나는데, 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
* '클래스 추출하기'로 필드들 일부를 따로 묶는다.

### 서로 다른 인터페이스의 대안 클래스들
* 클래스를 사용할 때의 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다.
* 교체하려면 인터페이스가 같아야 하므로, 메서드 시그니처를 일치시키고, '함수 옮기기'를 이용하여 인터페이스가 같아질 대까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
* 대안 클래스들 사이에 중복 코드가 생긴다면 '슈퍼 클래스 추출하기'를 적용할지 고려한다.

### 데이터 클래스
* 데이터 클래스는 getter/setter로만 구성된 클래스를 말한다.
* 다른 클래스가 너무 깊이까지 함부로 수정할 수 없도록 레코드를 캡슐화하는 것이 좋다.
* 다른 함수를 호출하여 얻은 데이터 클래스에는 동작 코드를 넣을 이유가 없으므로 불변으로 만드는 것이 좋다.

### 상속 포기
* 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 심하게 난다.
* 이럴 때는 '서브클래스를 위임으로 바꾸기'나 '슈퍼클래스를 위임으로 바꾸기'를 활용해서 상속 메커니즘에서 벗어난다.

### 주석
* 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 '함수 추출하기'를 적용해본다.
* 이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면 '함수 선언 바꾸기'로 함수 이름을 바꿔본다.
* 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 '어서션 추가하기'를 사용한다.
> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
* 몰 할지 모를 때라면 주석을 달아두면 좋다.
* 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 주석을 남긴다.
* 코드를 지금처럼 작성한 이유를 설명하는 용도로도 주석을 남길 수도 있다.
