## 객체 통째로 넘기기 (Preserve Whole Object)

### as-is
```javascript
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.height;
if (aPlan.withinRange(log, high)) {
    // ...
}
```

### to-be
```javascript
if (aPlan.withinRange(aRoom.daysTempRange)) {
    // ...
}
```

* 레코드를 통재로 넘기면 변화에 대응하기 쉽다.
  * 예를 들어, 그 함수가 더 다양한 데이터를 사용하도록 바뀌어도 매개변수 목록은 수정할 필요가 없다.
  * 매개변수 목록이 짧아져서 일반적으로는 함수 사용법이 더 쉬워진다.
* 레코드에 담긴 데이터 중 일부를 받는 함수가 여러 개라면 그 함수들끼리는 같은 데이터를 사용하는 부분이 있을 것이고, 그 부분의 로직이 중복될 가능성이 커지는데, 레코드를 통째로 넘기면 이러한 로직 중복을 없앨 수 있다.
* 함수가 레코드 자체에 의존하기를 원치 않을 때는 이 리팩토링을 수행하지 않는다. (레코드와 함수가 서로 다른 모듈에 속한 상황 등..)
* 어떤 객체로부터 값 몇 개를 얻은 후 그 값들만으로 무언가를 하는 로직이 있다면, 그 로직을 객체 안으로 집어넣어야 함을 알려주는 악취로 봐야 한다.
* 한 객체가 제공하는 기능 중 항상 똑같은 일부만을 사용하는 코드가 많다면, 그 기능만 따로 묶어서 클래스로 추출하라는 신호일 수도 있다.
* 다른 객체의 메서드를 호출하면서 호출하는 객체 자신이 가지고 있는 데이터 여러 개를 건네는 경우에 이 리팩토링을 적용한다.

- - -

### 절차
1. 매개변수들을 원하는 형태로 받는 빈 함수를 만든다.
2. 새 함수의 본문에서는 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑한다.
3. 정적 검사를 수행한다.
4. 모든 호출자가 새 함수를 사용하게 수정한다. 하나씩 수정하며 테스트한다.
5. 호출자를 모두 수정했다면 원래 함수를 인라인한다.
6. 새 함수의 이름을 적절히 수정하고 모든 호출자에 반영한다.
